
Este trabajo nos sirvió para aplicar y desarrollar el conocimiento adquirido en la materia a un tema que nos interesaba. Al finalizarlo pudimos realizar una red neuronal perfectamente funcional en $C$ y $ASSEMBLER$ a un problema concreto e interesante con una performance superior a la que obtenian expertos en el área hace menos de una década\footnote{\url{http://yann.lecun.com/exdb/mnist/}}, esto habría sido imposible sin cursar Organización del Computador 2. El trabajo desarrollado nos permitió aprender mas de los lenguajes de programación, herramientas de compilación, desarrollo de experimentos y demás temas que vimos en la materia.
\\
\\
Al finalizar este trabajo pudimos corroborar exitosamente la hipótesis de que la utilización de SIMD resultaría en una mejora en la performance temporal de nuestro programa en ciertas partes críticas. Viendo en detalle los resultados de nuestros experimentos pudimos ver como para algunos casos como $update_weight$ la implementación en $ASSEMBLER$ no valió la pena ya que sus tiempos fueron muy similares a los de su versión en $C$, como caso extremo tuvimos a $vector_sum$ el cuál mostro tiempos ligeramente mayores en $ASSEMBLER$ que en $C$, esto creemos que fue debido a que COMPLETAR.
\\
\\
Por otro lado métodos como $hadamard\_product$ y $matrix\_prod$ lograron tiempos considerablemente superiores con tiempos que duplicaron a sus versiones en $C$.
\\
\\
Cómo conclusión final entendemos que bajo ciertas circunstancias, donde mejoras en tiempo son cruciales, la utilización de SIMD puede ser una herramienta fundamental, aunque al mismo tiempo hay que tener en cuenta que los tiempos de desarrollo suelen ser mayores debido al bajo nivel de $ASSEMBLER$, incluso para funciones simples como las que hicimos y como vimos con $update_weight$ y $vector\_sum$ para algunos casos incluso pueden encontrarse resultados mediocres.